# Create Simulations
#' Generate simulations for comparison
#'
#' This function generates a dataframe containing multiple simulations of random data.
#'
#' The tests of this package rely on comparisons of the experimental data to simulated random data sets.
#' This function can provide a dataframe containing multiple simulated runs of the experiment with completely random data.
#' To generate the random data a software-based pseudo-RNG can be used or - better - the package provides text-files containing random bit sequences previously generated by a quantum-based trueRNG (Quantis).
#' Simulations can be created for binomial datasets and bits can be summed up to represent normally distributed mean scores.
#'
#' @param trials The amount of trials in a single experiment (this includes all subjects).
#' @param n.sims The amount of simulations to be generated. 10,000 is recommended, this might take several hours or days, though, depending on the sample size and number of trials.
#' @param mean.scores Should bits be summed up to represent a normal distribution centered about a mean? If yes, indicate the desired mean score here. If you are comparing to binomial data, set to NULL.
#' @param use.files Should the random data be taken out of the tRNG files (TRUE) or should a pseudo RNG be used (FALSE).
#' @param filespath If random files should be used indicate the path to those files.
#' @param parallel If set to TRUE, multiple cores are being used in parallel to generate the simulations (recommenden).
#' @return A dataframe with trials*nsims rows containing the columns "simid","index","rw","density.rw","bf" and "density.bf".
#' @examples
#' sims <- simcreate(100)
#' sims1000 <- simcreate(100, n.sims = 1000)
#' sims <- simcreate(600, mean.scores = 30)
#' sims.pseudo <- simcreate(2000, use.files = FALSE)
#' @export

simcreate <- function(trials, n.sims = 10000, mean.scores = NULL, use.files = TRUE, filespath = "simfiles/", parallel = TRUE){
  require(foreach)
  require(doParallel)

  u.trials <- trials
  print("Generating Simulations...")

  if(parallel == TRUE){
    print("This will probably take a while. See log.txt for status updates!")
    #setup parallel backend to use many processors
    cores=detectCores()
    cl <- makeCluster(cores[1]-1) #not to overload your computer
    registerDoParallel(cl)

    sim.out <- foreach(i=1:n.sims, .combine=rbind) %dopar% {
      sink("log.txt", append = TRUE)
      cat(paste(Sys.time(),"Starting iteration",i,"\n"))
      sink()

      if(use.files == TRUE){
        # read txt
        sim <- read.table(paste0(filespath,"/",i,".txt"))
        line.start <- sample.int(nrow(sim)-(u.trials),1)
        line.stop <- line.start+u.trials-1
        sim <- data.frame(V1=sim[line.start:line.stop,])
      } else {
        sim <- data.frame(V1=rbinom(u.trials, 1, 0.5))
      }

      if(!is.null(mean.scores)){
        # sum up bits
        sim$group = rep(1:(nrow(sim)/(mean.scores*2)), each=mean.scores*2)
        sim <- tapply(sim[,1], sim$group, FUN = sum)
        sim <- data.frame(sums=sim)
        sim$cumsum <- cumsum(sim$sums-mean.scores)

        # BAYES t TEST
        sim$bf <- 1
        for (b in 5:nrow(sim)){
          tmpbf <- BayesFactor::ttestBF(x = sim$sums[1:b], mu = mean.scores, rscale = 0.1, nullInterval = c(0, Inf))
          sim$bf[b] <- exp(tmpbf@bayesFactor$bf)[1]
        }

      } else {
        sim$qbitmin1 <- ifelse(sim[,1] == 0, -1, 1)
        sim$cumsum <- cumsum(sim$qbitmin1)

        #(2) BAYES BINOM TEST
        sim$bf <- 1
        for (b in 5:nrow(sim)){
          tmpbf <- BayesFactor::proportionBF(sum(sim$V1[1:b]), b, p = .5, rscale = 0.1)
          sim$bf[b] <- exp(tmpbf@bayesFactor$bf)
        }
      }

      # Run FFT on Random Walk
      L <- length(sim$cumsum) # Länge
      T <- 1/L # Tastrate
      Y <- fft(sim$cumsum) # Fast Fourier Transformation
      P <- abs(Y/L)

      # Run FFT on Bayes Test
      Y2 <- fft(sim$bf) # Fast Fourier Transformation
      P2 <- abs(Y2/L)

      # Write results to Matrix
      index <- as.numeric(1:L)
      tempMatrix <- data.frame(simid=i, index=index, rw=sim$cumsum, density.rw=P, bf=sim$bf, density.bf=P2)

      tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
    }


    #stop cluster
    stopCluster(cl)
    colnames(sim.out) <- c("simid","index","rw","density.rw","bf","density.bf")
  } else{
    # Parallel = FALSE
    sim.out <- list()

    pb = txtProgressBar(min = 0, max = n.sims, initial = 0, style = 3)
    for(i in 1:n.sims){
      if(use.files == TRUE){
        # read txt
        sim <- read.table(paste0(filespath,"/",i,".txt"))
        line.start <- sample.int(nrow(sim)-(u.trials),1)
        line.stop <- line.start+u.trials-1
        sim <- data.frame(V1=sim[line.start:line.stop,])
      } else {
        sim <- data.frame(V1=rbinom(u.trials, 1, 0.5))
      }

      if(!is.null(mean.scores)){
        # sum up bits
        sim$group = rep(1:(nrow(sim)/(mean.scores*2)), each=mean.scores*2)
        sim <- tapply(sim[,1], sim$group, FUN = sum)
        sim <- data.frame(sums=sim)
        sim$cumsum <- cumsum(sim$sums-mean.scores)

        # BAYES t TEST
        sim$bf <- 1
        for (b in 5:nrow(sim)){
          tmpbf <- BayesFactor::ttestBF(x = sim$sums[1:b], mu = mean.scores, rscale = 0.1, nullInterval = c(0, Inf))
          sim$bf[b] <- exp(tmpbf@bayesFactor$bf)[1]
        }

      } else {
        sim$qbitmin1 <- ifelse(sim[,1] == 0, -1, 1)
        sim$cumsum <- cumsum(sim$qbitmin1)

        #(2) BAYES BINOM TEST
        sim$bf <- 1
        for (b in 5:nrow(sim)){
          tmpbf <- BayesFactor::proportionBF(sum(sim$V1[1:b]), b, p = .5, rscale = 0.1)
          sim$bf[b] <- exp(tmpbf@bayesFactor$bf)
        }
      }

      # Run FFT on Random Walk
      L <- length(sim$cumsum) # Länge
      T <- 1/L # Tastrate
      Y <- fft(sim$cumsum) # Fast Fourier Transformation
      P <- abs(Y/L)

      # Run FFT on Bayes Test
      Y2 <- fft(sim$bf) # Fast Fourier Transformation
      P2 <- abs(Y2/L)

      # Write results to Matrix
      index <- as.numeric(1:L)
      tempMatrix <- data.frame(simid=i, index=index, rw=sim$cumsum, density.rw=P, bf=sim$bf, density.bf=P2)

      sim.out[[i]] <- tempMatrix
      setTxtProgressBar(pb,i)

    }

    sim.out <- dplyr::bind_rows(sim.out)
  }

  return(sim.out)
}
